@GenModel(
	operationReflection="false",
	loadInitialization="false",
	literalsInterface="true")
package alpha.model

import alpha.model.exception.CyclicDefinitionException
import alpha.model.util.AlphaPrintingUtil
import alpha.model.util.AlphaUtil
import fr.irisa.cairn.jnimap.isl.jni.ISL_FORMAT
import fr.irisa.cairn.jnimap.isl.jni.JNIISLMap
import fr.irisa.cairn.jnimap.isl.jni.JNIISLMultiAff
import fr.irisa.cairn.jnimap.isl.jni.JNIISLSet
import fr.irisa.cairn.jnimap.isl.jni.JNIISLUnionMap
import fr.irisa.cairn.jnimap.runtime.JNIObject
import java.util.LinkedList
import java.util.List
import java.util.Queue
import org.eclipse.emf.common.util.BasicEList
import org.eclipse.xtext.EcoreUtil2
import org.eclipse.xtext.naming.DefaultDeclarativeQualifiedNameProvider
import org.eclipse.xtext.naming.IQualifiedNameProvider

//type JNIDomain wraps JNIDomain
type JNIObject wraps JNIObject
type JNIISLSet wraps JNIISLSet
type JNIISLMap wraps JNIISLMap
type JNIISLMultiAff wraps JNIISLMultiAff
type JNIISLUnionMap wraps JNIISLUnionMap
type ISL_FORMAT wraps ISL_FORMAT
type ListVariableExpression wraps List<VariableExpression> 
type IntegerQueue wraps Queue<Integer>


/*
 * Some conventions:
 *  polyhedral objects are either domains or relations in Alpha terms
 * the above is distinguished from ISL objects that are named sets or maps
 * 
 * TODO make sure calculator expression does not have cycles in its evaluation chain
 *   VariableDomain and DefinedObject should only refer to textually preceding definitions
 */

class AlphaNode {
	derived int[] nodeID get {
		val parentID = if (eContainer instanceof AlphaNode) {
			new BasicEList<Integer>((eContainer as AlphaNode).nodeID);
		} else {
			new BasicEList<Integer>();
		}
		if (eContainer !== null)
			parentID.add(eContainer.eContents.indexOf(this))
		return parentID
	}
	
	op AlphaNode getNode(IntegerQueue nodeID) {
		val next = nodeID.poll;
		
		if (next === null) this
		else (this.eContents.get(next) as AlphaNode).getNode(nodeID);
	}
	
	op AlphaNode getNode(String nodeID) {
		getNode(new LinkedList<Integer>(nodeID.replace('[', '').replace(']', '').split("\\s*,\\s*").map[e|Integer.parseInt(e)]))
	}
}


/**
 * Interface for AlphaCompleteVisitor, which actually is not complete in the sense it does not visit CalculatorExpression.
 * This is because CalculatorExpressions are separate data structure to describe polyhedral objects, which is tightly
 * coupled with JNIISL.
 * 
 */
interface AlphaCompleteVisitable {}

interface AlphaVisitable extends AlphaCompleteVisitable {
	op void accept(AlphaVisitor visitor)
}
interface AlphaExpressionVisitable extends AlphaCompleteVisitable {
	op void accept(AlphaExpressionVisitor visitor)
}
interface CalculatorExpressionVisitable {
	op void accept(CalculatorExpressionVisitor visitor)
}
interface AlphaSystemElement {}

/**
 * Notes on visitors.
 * 
 * - Whenever you add a new node, the corresponding methods must be added to the visitor interface.
 * - Each node should have visitXXX, inXXX, outXXX methods.
 * - The default visiting pattern (depth first) is implemented in the corresponding default visitors. They need to be updated when a node is added as well.
 * - In the default visitor, inXXX and outXXX is called from visitXXX, where visitXXX calls accept on all its children. 
 * - The abstract visitor does not need to be modified, except for the CompleteVisitor that require bridging between two visitors.
 * 
 * The default methods are used so that the visiting pattern can be implemented at the interface of each visitor. 
 * This allows the complete visitor, which is made up of two visitors, to reuse the visiting code.  
 * 
 */
interface AlphaVisitor {
	op void visitAlphaRoot(AlphaRoot root)
	
	op void visitAlphaPackage(AlphaPackage ap)
	op void visitAlphaSystem(AlphaSystem system)
	op void visitSystemBody(SystemBody sysBody)
	op void visitImports(Imports imports)
	op void visitAlphaConstant(AlphaConstant ac)
	op void visitExternalFunction(ExternalFunction ef)
	
	/* Use specialized methods for input/output/local specific operations.
	 * The abstract visitor calls the specialized methods, which then calls the generic visitor.
	 */
	op void visitVariable(Variable variable)
	
	op void visitPolyhedralObject(PolyhedralObject pobj)

	op void visitUseEquation(UseEquation ue)
	op void visitStandardEquation(StandardEquation se)
	
	
	op void inAlphaRoot(AlphaRoot root)
	
	op void inAlphaElement(AlphaElement ap)
	op void inAlphaPackage(AlphaPackage ap)
	op void inAlphaSystem(AlphaSystem system)
	op void inSystemBody(SystemBody sysBody)
	op void inImports(Imports imports)
	op void inAlphaConstant(AlphaConstant ac)
	op void inExternalFunction(ExternalFunction ef)
	
	op void inVariable(Variable variable)
	
	op void inFuzzyVariable(FuzzyVariable variable)
	
	op void inPolyhedralObject(PolyhedralObject pobj)


	op void inEquation(Equation eq)
	op void inUseEquation(UseEquation ue)
	op void inStandardEquation(StandardEquation se)
	
	
	op void outAlphaRoot(AlphaRoot root)
	
	op void outAlphaElement(AlphaElement ap)
	op void outAlphaPackage(AlphaPackage ap)
	op void outAlphaSystem(AlphaSystem system)
	op void outSystemBody(SystemBody sysBody)
	op void outImports(Imports imports)
	op void outAlphaConstant(AlphaConstant ac)
	op void outExternalFunction(ExternalFunction ef)
	
	op void outVariable(Variable variable)
	
	op void outFuzzyVariable(FuzzyVariable variable)
	
	op void outPolyhedralObject(PolyhedralObject pobj)

	op void outEquation(Equation eq)
	op void outUseEquation(UseEquation ue)
	op void outStandardEquation(StandardEquation se)
}

interface AlphaExpressionVisitor {
	op void visitAlphaExpression(AlphaExpression ae)
	
	op void visitRestrictExpression(RestrictExpression re)
	op void visitAutoRestrictExpression(AutoRestrictExpression are)
	op void visitCaseExpression(CaseExpression ce)
	op void visitIfExpression(IfExpression ie)
	op void visitDependenceExpression(DependenceExpression de)
	op void visitFuzzyDependenceExpression(FuzzyDependenceExpression fde)
	op void visitAbstractReduceExpression(AbstractReduceExpression are)
	op void visitAbstractFuzzyReduceExpression(AbstractFuzzyReduceExpression afre)
	op void visitConvolutionExpression(ConvolutionExpression ce)
	op void visitUnaryExpression(UnaryExpression ue)
	op void visitBinaryExpression(BinaryExpression be)
	op void visitMultiArgExpression(MultiArgExpression mae)
	op void visitSelectExpression(SelectExpression se)
	
	op void visitIndexExpression(IndexExpression ie)
	op void visitFuzzyIndexExpression(FuzzyIndexExpression fie)
	op void visitVariableExpression(VariableExpression ve)
	
	op void visitIntegerExpression(IntegerExpression ie)
	op void visitRealExpression(RealExpression re)
	op void visitBooleanExpression(BooleanExpression be)
	
	op void inAlphaExpression(AlphaExpression ae)
	
	op void inRestrictExpression(RestrictExpression re)
	op void inAutoRestrictExpression(AutoRestrictExpression are)
	op void inCaseExpression(CaseExpression ce)
	op void inIfExpression(IfExpression ie)
	op void inDependenceExpression(DependenceExpression de)
	op void inFuzzyDependenceExpression(FuzzyDependenceExpression fde)
	op void inAbstractReduceExpression(AbstractReduceExpression are)
	op void inReduceExpression(ReduceExpression re)
	op void inArgReduceExpression(ArgReduceExpression are)
	op void inAbstractFuzzyReduceExpression(AbstractFuzzyReduceExpression afre)
	op void inFuzzyReduceExpression(FuzzyReduceExpression fre)
	op void inFuzzyArgReduceExpression(FuzzyArgReduceExpression fare)
	op void inConvolutionExpression(ConvolutionExpression ce)
	op void inUnaryExpression(UnaryExpression ue)
	op void inBinaryExpression(BinaryExpression be)
	op void inMultiArgExpression(MultiArgExpression mae)
	op void inSelectExpression(SelectExpression se)
	
	op void inIndexExpression(IndexExpression ie)
	op void inFuzzyIndexExpression(FuzzyIndexExpression fie)
	op void inVariableExpression(VariableExpression ve)
	
	op void inConstantExpression(ConstantExpression ce)
	op void inIntegerExpression(IntegerExpression ie)
	op void inRealExpression(RealExpression re)
	op void inBooleanExpression(BooleanExpression be)
	
	op void inExternalReduceExpression(ExternalReduceExpression ere)
	op void inExternalArgReduceExpression(ExternalArgReduceExpression eare)
	op void inExternalMultiArgExpression(ExternalMultiArgExpression emae)
	op void inExternalFuzzyReduceExpression(ExternalFuzzyReduceExpression efre)
	op void inExternalFuzzyArgReduceExpression(ExternalFuzzyArgReduceExpression efare)
	
	op void outAlphaExpression(AlphaExpression ae)
	
	op void outRestrictExpression(RestrictExpression re)
	op void outAutoRestrictExpression(AutoRestrictExpression are)
	op void outCaseExpression(CaseExpression ce)
	op void outIfExpression(IfExpression ie)
	op void outDependenceExpression(DependenceExpression de)
	op void outFuzzyDependenceExpression(FuzzyDependenceExpression fde)
	op void outAbstractReduceExpression(AbstractReduceExpression are)
	op void outReduceExpression(ReduceExpression re)
	op void outArgReduceExpression(ArgReduceExpression are)
	op void outAbstractFuzzyReduceExpression(AbstractFuzzyReduceExpression afre)
	op void outFuzzyReduceExpression(FuzzyReduceExpression fre)
	op void outFuzzyArgReduceExpression(FuzzyArgReduceExpression fare)
	op void outConvolutionExpression(ConvolutionExpression ce)
	op void outUnaryExpression(UnaryExpression ue)
	op void outBinaryExpression(BinaryExpression be)
	op void outMultiArgExpression(MultiArgExpression mae)
	op void outSelectExpression(SelectExpression se)
	
	op void outIndexExpression(IndexExpression ie)
	op void outFuzzyIndexExpression(FuzzyIndexExpression fie)
	op void outVariableExpression(VariableExpression ve)
	
	op void outConstantExpression(ConstantExpression ce)
	op void outIntegerExpression(IntegerExpression ie)
	op void outRealExpression(RealExpression re)
	op void outBooleanExpression(BooleanExpression be)
	
	op void outExternalReduceExpression(ExternalReduceExpression ere)
	op void outExternalArgReduceExpression(ExternalArgReduceExpression eare)
	op void outExternalMultiArgExpression(ExternalMultiArgExpression emae)
	op void outExternalFuzzyReduceExpression(ExternalFuzzyReduceExpression efre)
	op void outExternalFuzzyArgReduceExpression(ExternalFuzzyArgReduceExpression efare)
}

interface CalculatorExpressionVisitor {
	op void visitCalculatorExpression(CalculatorExpression expr)
	
	op void visitUnaryCalculatorExpression(UnaryCalculatorExpression expr)
	op void visitBinaryCalculatorExpression(BinaryCalculatorExpression expr)
	
	op void visitJNIDomain(JNIDomain jniDomain)
	op void visitJNIRelation(JNIRelation jniRelation)
	op void visitJNIFunction(JNIFunction jniFunction)
	
	op void visitVariableDomain(VariableDomain vdom)
	op void visitRectangularDomain(RectangularDomain rdom)
	op void visitDefinedObject(DefinedObject dobj)
}

class AlphaRoot extends AlphaNode, AlphaVisitable {
	contains Imports[] imports
	contains AlphaElement[] elements
	
	op AlphaConstant[] getConstants() { EcoreUtil2.getAllContentsOfType(this, AlphaConstant).asEList }
	op ExternalFunction[] getExternalFunctions() { EcoreUtil2.getAllContentsOfType(this, ExternalFunction).asEList }
	op AlphaPackage[] getPackages() { EcoreUtil2.getAllContentsOfType(this, AlphaPackage).asEList }
	op AlphaSystem[] getSystems() { EcoreUtil2.getAllContentsOfType(this, AlphaSystem).asEList }
	
	op AlphaSystem getSystem(String name) {
		//qualified name
		if (name.contains('.')) {
			val system =  EcoreUtil2.getAllContentsOfType(this, AlphaSystem).findFirst[s|s.getFullyQualifiedName.contentEquals(name)]
			if (system !== null) return system
		//just the system name
		} else {
			val system = EcoreUtil2.getAllContentsOfType(this, AlphaSystem).findFirst[s|s.name.contentEquals(name)]
			if (system !== null) return system
		}
		
		throw new RuntimeException("System " + name + " was not found.");
	}
	
	op void accept(AlphaVisitor visitor) {
		visitor.visitAlphaRoot(this)
	}
}

/**
 * AlphaElement is introduced to allow systems, packages, constants, and exFuns, to appear in any order.
 * The imports must be at the beginning of the file.
 * 
 */
interface AlphaElement extends AlphaNode, AlphaVisitable {
}

class Imports extends AlphaNode, AlphaVisitable {
	String importedNamespace
	
	op void accept(AlphaVisitor visitor) {
		visitor.visitImports(this)
	}
}

class AlphaPackage extends AlphaElement {
	 String name
	 contains AlphaElement[] elements
	 
	op AlphaConstant[] getConstants() { elements.filter(AlphaConstant).asEList }
	op ExternalFunction[] getExternalFunctions() { elements.filter(ExternalFunction).asEList }
	op AlphaPackage[] getPackages() { elements.filter(AlphaPackage).asEList }
	op AlphaSystem[] getSystems() { elements.filter(AlphaSystem).asEList }
	 
	 op void accept(AlphaVisitor visitor) {
		visitor.visitAlphaPackage(this)
	}
}

class AlphaConstant extends AlphaElement {
	String name
	int value 
	
	op void accept(AlphaVisitor visitor) {
		visitor.visitAlphaConstant(this)
	}
}

class ExternalFunction extends AlphaElement {
	String name
	int cardinality
	
	op void accept(AlphaVisitor visitor) {
		visitor.visitExternalFunction(this)
	}
}

class AlphaSystem extends AlphaElement {
	String name
	contains JNIDomain parameterDomainExpr
	contains PolyhedralObject[] definedObjects
	contains Variable[] inputs
	contains Variable[] outputs
	contains Variable[] locals
	contains CalculatorExpression whileDomainExpr
	contains AlphaExpression testExpression
	
	contains SystemBody[] systemBodies opposite system
	
	op Variable[] getVariables() {
		(inputs+outputs+locals).asEList.unmodifiableEList
	}
	
	op JNIISLSet getParameterDomain() {
		return parameterDomainExpr.ISLSet
	}
	
	op JNIISLSet getWhileDomain() {
		if (whileDomainExpr === null || whileDomainExpr.^type != POLY_OBJECT_TYPE::SET) null 
		else (whileDomainExpr.ISLObject as JNIISLSet).copy
	}
	
	op Variable getVariable(String varName) {
		return getVariables.findFirst[v|v.name.contentEquals(varName)]
	}
	
	op String getFullyQualifiedName() {
		val IQualifiedNameProvider provider = new DefaultDeclarativeQualifiedNameProvider;
		provider.getFullyQualifiedName(this).toString
	}
	
	op void accept(AlphaVisitor visitor) {
		visitor.visitAlphaSystem(this)
	}
}


class Variable extends AlphaNode, AlphaVisitable, AlphaSystemElement {
	String name
	contains CalculatorExpression domainExpr
	
	op JNIISLSet getDomain() {
		if (domainExpr.^type != POLY_OBJECT_TYPE::SET) {
			return null
		}
		
		try {
			return if (domainExpr.^type != POLY_OBJECT_TYPE::SET) null else domainExpr.ISLObject as JNIISLSet
		} catch (CyclicDefinitionException cde) {
			return null
		}
	}
	
	op boolean isInput() {
		eContainmentFeature !== null && eContainmentFeature === ModelPackage.Literals.ALPHA_SYSTEM__INPUTS
	}
	op boolean isOutput() {
		eContainmentFeature !== null && eContainmentFeature === ModelPackage.Literals.ALPHA_SYSTEM__OUTPUTS
	}
	op boolean isLocal() {
		eContainmentFeature !== null && eContainmentFeature === ModelPackage.Literals.ALPHA_SYSTEM__LOCALS
	}
	
	 op void accept(AlphaVisitor visitor) {
	 	visitor.visitVariable(this)
	}
}

class FuzzyVariable extends Variable {
	contains CalculatorExpression rangeExpr
	
	op JNIISLSet getRange() {
		return if (rangeExpr.^type != POLY_OBJECT_TYPE::SET) null else rangeExpr.ISLObject as JNIISLSet
	}
	
	op JNIISLMap getRelation() {
		val dom = domain
		val ran = range
		if (dom === null || ran === null) null else dom.product(ran).unwrap
	}
	
	op void accept(AlphaVisitor visitor) {
	 	visitor.visitVariable(this)
	}
}

class SystemBody extends AlphaNode, AlphaVisitable, AlphaSystemElement {
	container AlphaSystem system opposite systemBodies
	contains JNIDomain parameterDomainExpr
	contains Equation[] equations opposite systemBody
	
	op JNIISLSet getParameterDomain() {
		return parameterDomainExpr.ISLSet
	}
	
	op UseEquation[] getUseEquations() {
		equations.getObjectsByType(ModelPackage.Literals.USE_EQUATION).asEList
	}
	op StandardEquation[] getStandardEquations() {
		equations.getObjectsByType(ModelPackage.Literals.STANDARD_EQUATION).asEList
	}
	
//	op Variable getEquation(String eqName) {
//		val v = standard.findFirst[eq|e.name.contentEquals(varName)]
//		
//		if (v === null) {
//			throw new RuntimeException(String.format("Variable %s does not exist in system %s ", varName, this.name));
//		}
//		
//		return v
//	}

	op StandardEquation getStandardEquation(String eqName) {
		standardEquations.findFirst[eq|eq.variable.name.contentEquals(eqName)]
	}
	
	op StandardEquation getStandardEquation(Variable v) {
		standardEquations.findFirst[eq|eq.variable == v]
	}
//	
//	op UseEquation getUseEquation(String eqName) {
//		ue.
//		
////		val v = useEquations.filter[ue|EcoreUtil2.getAllContentsOfType(ue, VariableExpression).filter[ve|ve.variable.name]]
////		
////		if (v === null) {
////			throw new RuntimeException(String.format("StanardEquation for %s does not exist in system %s ", eqName, this.system.name));
////		}
////		
////		return v
//	}
	
	op void accept(AlphaVisitor visitor) {
		visitor.visitSystemBody(this)
	}
}

abstract class Equation extends AlphaNode, AlphaVisitable, AlphaSystemElement {
	container SystemBody systemBody opposite equations
	
	op AlphaExpression getExpression(IntegerQueue exprID) {
		val next = exprID.poll;
		
		if (next === null) throw new RuntimeException("Invalid Expression ID")
		else (this.eContents.get(next) as AlphaExpression).getExpression(exprID);
	}
	
	op AlphaExpression getExpression(String exprID) {
		getExpression(new LinkedList<Integer>(exprID.replace('[', '').replace(']', '').split("\\s*,\\s*").map[e|Integer.parseInt(e)]))
	}
}

class StandardEquation extends Equation {
	refers Variable variable
	String[] indexNames
	contains AlphaExpression expr
	
	op void accept(AlphaVisitor visitor) {
		visitor.visitStandardEquation(this)
	}
}
class UseEquation extends Equation {
	contains CalculatorExpression instantiationDomainExpr
	String[] subsystemDims
	refers AlphaSystem system
	contains JNIFunctionInArrayNotation callParamsExpr
	contains AlphaExpression[] inputExprs
	contains AlphaExpression[] outputExprs
	
	op JNIISLMultiAff getCallParams() {
		if (callParamsExpr.^type != POLY_OBJECT_TYPE.FUNCTION) null
		else callParamsExpr.ISLObject as JNIISLMultiAff
	}
	
	op JNIISLSet getInstantiationDomain() {
		if (instantiationDomainExpr.^type != POLY_OBJECT_TYPE.SET) null
		else instantiationDomainExpr.ISLObject as JNIISLSet
	}
	
	op ListVariableExpression getAllVariableExpressionsInOutputExpressions() {
		var List<VariableExpression> list = new LinkedList<VariableExpression>();
		for(expr : outputExprs) {
			list.addAll(EcoreUtil2.getAllContentsOfType(expr, VariableExpression))
			
			if (expr instanceof VariableExpression) {
				list.add(expr);
			}
		}
		return list
	}
	
	op void accept(AlphaVisitor visitor) {
		visitor.visitUseEquation(this)
	}
}

/** Alpha Expressions 
 *
 * XCore does not provide a way to make private variables in the classes. The current work around 
 * is to use long and obvious names for internal variables that are not meant to be accessed. In
 * the AlphaExpression classes, these variables are prefixed by z__internal, where the leading
 * 'z' makes the corresponding methods to show up at the bottom of the content assist.
 * 
 * For JNIISL objects, any getter should return a copy of the object to ensure that the object
 * will not be taken by ISL.
 * 
 */

abstract class AlphaExpression extends AlphaNode, AlphaExpressionVisitable {
	/*Internal object for always copying expression domain at getter */
	JNIISLSet z__internal_cache_exprDom
	/*Internal object for always copying context domain at getter */
	JNIISLSet z__internal_cache_contextDom
	
	derived int[] expressionID get {
		val parentID = if (eContainer instanceof AlphaExpression) {
			new BasicEList<Integer>((eContainer as AlphaExpression).expressionID);
		} else {
			new BasicEList<Integer>();
		}
		parentID.add(eContainer.eContents.indexOf(this))
		return parentID
	}
	
	op void setExpressionDomain(JNIISLSet dom) { this.setZ__internal_cache_exprDom(dom.coalesce) }
	op JNIISLSet getExpressionDomain() { if (z__internal_cache_exprDom !== null) z__internal_cache_exprDom.copy else null }
	
	op void setContextDomain(JNIISLSet dom) { this.setZ__internal_cache_contextDom(dom.coalesce) }
	op JNIISLSet getContextDomain() { if (z__internal_cache_contextDom !== null)  z__internal_cache_contextDom.copy else null }
	
	op AlphaExpression getExpression(IntegerQueue exprID) {
		val next = exprID.poll;
		
		if (next === null) this
		else (this.eContents.get(next) as AlphaExpression).getExpression(exprID);
	}
}

class RestrictExpression extends AlphaExpression {
	contains CalculatorExpression domainExpr
	contains AlphaExpression expr
	
	op JNIISLSet getRestrictDomain() {
		if (domainExpr.^type != POLY_OBJECT_TYPE.SET ) null
		else domainExpr.ISLObject as JNIISLSet
	}
	
	op void accept(AlphaExpressionVisitor visitor) {
		visitor.visitRestrictExpression(this)
	}
}
class AutoRestrictExpression extends AlphaExpression {
	contains AlphaExpression expr
	JNIISLSet z__internal_cache_inferredDomain
	
	op JNIISLSet getInferredDomain() { if (z__internal_cache_inferredDomain !== null) z__internal_cache_inferredDomain.copy else null }
	op void setInferredDomain(JNIISLSet islset) { z__internal_cache_inferredDomain = islset }
		
	op void accept(AlphaExpressionVisitor visitor) {
		visitor.visitAutoRestrictExpression(this)
	}
}

class CaseExpression extends AlphaExpression {
	String name
	contains AlphaExpression[] exprs
	
	op boolean isNamed() {
		name !== null && name.length > 0
	}
	
	op void accept(AlphaExpressionVisitor visitor) {
		visitor.visitCaseExpression(this)
	}
}
class DependenceExpression extends AlphaExpression {
	contains JNIFunction functionExpr
	contains AlphaExpression expr
	
	op JNIISLMultiAff getFunction() {
		if (functionExpr.^type != POLY_OBJECT_TYPE.FUNCTION ) null
		else functionExpr.ISLObject as JNIISLMultiAff
	}
	
	op void accept(AlphaExpressionVisitor visitor) {
		visitor.visitDependenceExpression(this)
	}
}
class FuzzyDependenceExpression extends AlphaExpression {
	contains FuzzyFunction fuzzyFunction
	contains AlphaExpression expr
	
	op JNIISLMap getDependenceRelation() {
		if (fuzzyFunction !== null) fuzzyFunction.dependenceRelation else null
	}
	
	op void accept(AlphaExpressionVisitor visitor) {
		visitor.visitFuzzyDependenceExpression(this)
	}
}
class IfExpression extends AlphaExpression {
	contains AlphaExpression condExpr
	contains AlphaExpression thenExpr
	contains AlphaExpression elseExpr
	
	op void accept(AlphaExpressionVisitor visitor) {
		visitor.visitIfExpression(this)
	}
}
class IndexExpression extends AlphaExpression {
	contains JNIFunction functionExpr
	
	op JNIISLMultiAff getFunction() {
		if (functionExpr.^type != POLY_OBJECT_TYPE.FUNCTION ) null
		else functionExpr.ISLObject as JNIISLMultiAff
	}
	
	op void accept(AlphaExpressionVisitor visitor) {
		visitor.visitIndexExpression(this)
	}
}

class FuzzyIndexExpression extends AlphaExpression {	
	contains FuzzyFunction fuzzyFunction
	
	op JNIISLMap getDependenceRelation() {
		if (fuzzyFunction !== null) fuzzyFunction.dependenceRelation else null
	}
	
	op void accept(AlphaExpressionVisitor visitor) {
		visitor.visitFuzzyIndexExpression(this)
	}
}


abstract class AbstractReduceExpression extends AlphaExpression {
	REDUCTION_OP operator
	contains JNIFunction projectionExpr
	contains AlphaExpression body
	
	op JNIISLMultiAff getProjection() {
		if (projectionExpr.^type != POLY_OBJECT_TYPE.FUNCTION ) null
		else projectionExpr.ISLObject as JNIISLMultiAff
	}
	
	op void accept(AlphaExpressionVisitor visitor) {
		visitor.visitAbstractReduceExpression(this)
	}
}
class ReduceExpression extends AbstractReduceExpression {
	
	op void accept(AlphaExpressionVisitor visitor) {
		visitor.visitAbstractReduceExpression(this)
	}
}
class ExternalReduceExpression extends ReduceExpression {
	refers ExternalFunction externalFunction
	
	op void accept(AlphaExpressionVisitor visitor) {
		visitor.visitAbstractReduceExpression(this)
	}
}
class ArgReduceExpression extends AbstractReduceExpression {
	
	op void accept(AlphaExpressionVisitor visitor) {
		visitor.visitAbstractReduceExpression(this)
	}
}
class ExternalArgReduceExpression extends ArgReduceExpression {
	refers ExternalFunction externalFunction
	
	op void accept(AlphaExpressionVisitor visitor) {
		visitor.visitAbstractReduceExpression(this)
	}
}
class ConvolutionExpression extends AlphaExpression {
	contains CalculatorExpression kernelDomainExpr
	contains AlphaExpression kernelExpression
	contains AlphaExpression dataExpression
	
	op JNIISLSet getKernelDomain() {
		if (kernelDomainExpr.^type != POLY_OBJECT_TYPE.SET ) null
		else kernelDomainExpr.ISLObject as JNIISLSet
	}

	op void accept(AlphaExpressionVisitor visitor) {
		visitor.visitConvolutionExpression(this)
	}
}
class SelectExpression extends AlphaExpression {
	contains CalculatorExpression relationExpr
	contains AlphaExpression expr
	
	op JNIISLMap getSelectRelation() {
		if (relationExpr.^type != POLY_OBJECT_TYPE.MAP) null
		else relationExpr.ISLObject as JNIISLMap
	}

	op void accept(AlphaExpressionVisitor visitor) {
		visitor.visitSelectExpression(this)
	}
}
class VariableExpression extends AlphaExpression {
	refers Variable variable
	
	op void accept(AlphaExpressionVisitor visitor) {
		visitor.visitVariableExpression(this)
	}
}
interface ConstantExpression extends AlphaExpression {
	
	op String valueString()
}
class IntegerExpression extends ConstantExpression {
	int value
	
	op String valueString() { value+"" }
	
	op void accept(AlphaExpressionVisitor visitor) {
		visitor.visitIntegerExpression(this)
	}
}
class RealExpression extends ConstantExpression {
	float value
	
	op String valueString() { value+"" }
	
	op void accept(AlphaExpressionVisitor visitor) {
		visitor.visitRealExpression(this)
	}
}
class BooleanExpression extends ConstantExpression {
	boolean value
	
	op String valueString() { value+"" }
	
	op void accept(AlphaExpressionVisitor visitor) {
		visitor.visitBooleanExpression(this)
	}
}
class UnaryExpression extends AlphaExpression {
	UNARY_OP operator
	contains AlphaExpression expr
	
	op void accept(AlphaExpressionVisitor visitor) {
		visitor.visitUnaryExpression(this)
	}
}
class BinaryExpression extends AlphaExpression {
	BINARY_OP operator
	contains AlphaExpression left
	contains AlphaExpression right
	
	op void accept(AlphaExpressionVisitor visitor) {
		visitor.visitBinaryExpression(this)
	}
}
class MultiArgExpression extends AlphaExpression {
	REDUCTION_OP operator
	contains AlphaExpression[] exprs
	
	op void accept(AlphaExpressionVisitor visitor) {
		visitor.visitMultiArgExpression(this)
	}
}
class ExternalMultiArgExpression extends MultiArgExpression {
	refers ExternalFunction externalFunction 
	
	op void accept(AlphaExpressionVisitor visitor) {
		visitor.visitMultiArgExpression(this)
	}
}

abstract class AbstractFuzzyReduceExpression extends AlphaExpression {
	REDUCTION_OP operator
	contains FuzzyFunction projectionFunction
	contains AlphaExpression body
	
	op JNIISLMap getProjection() {
		if (projectionFunction !== null) projectionFunction.dependenceRelation else null
	}
	
	op void accept(AlphaExpressionVisitor visitor) {
		visitor.visitAbstractFuzzyReduceExpression(this)
	}
}
class FuzzyReduceExpression extends AbstractFuzzyReduceExpression {
	
	op void accept(AlphaExpressionVisitor visitor) {
		visitor.visitAbstractFuzzyReduceExpression(this)
	}
}
class ExternalFuzzyReduceExpression extends FuzzyReduceExpression {
	refers ExternalFunction externalFunction
	
	op void accept(AlphaExpressionVisitor visitor) {
		visitor.visitAbstractFuzzyReduceExpression(this)
	}
}
class FuzzyArgReduceExpression extends AbstractFuzzyReduceExpression {
	
	op void accept(AlphaExpressionVisitor visitor) {
		visitor.visitAbstractFuzzyReduceExpression(this)
	}
}
class ExternalFuzzyArgReduceExpression extends FuzzyArgReduceExpression {
	refers ExternalFunction externalFunction
	
	op void accept(AlphaExpressionVisitor visitor) {
		visitor.visitAbstractFuzzyReduceExpression(this)
	}
}

enum UNARY_OP {
	NOT as "not"
	NEGATE as "-"
}

enum BINARY_OP {
	MIN as "min"
	MAX as "max"
	
	MUL as "*"
	DIV as "/"
	MOD as "%"
	
	ADD as "+"
	SUB as "-"
	
	AND as "and"
	OR  as "or"
	XOR as "xor"
	
	EQ as "="
	NE as "!="
	GE as ">="
	GT as ">"
	LE as "<="
	LT as "<"
}

enum REDUCTION_OP {
	MIN as "min"
	MAX as "max"
	PROD as "prod"
	SUM as "sum"
	AND as "and"
	OR as "or"
	XOR as "xor"
	
	EX as "external"
}


/** Calculator Expressions **/
enum POLY_OBJECT_TYPE {
	SET
	MAP
	FUNCTION
}

enum CALCULATOR_UNARY_OP {
	GET_DOMAIN as "domain"
	GET_RANGE as "range"
	COMPLEMENT as "complement"
	POLYHEDRAL_HULL as "poly-hull"
	AFFINE_HULL as "affine-hull"
	REVERSE as "reverse"
}

enum CALCULATOR_BINARY_OP {
	INTERSECT as "*"
	UNION as "+"
	CROSS_PRODUCT as "cross"
	SET_DIFFERENCE as "-"
	JOIN as "@"
	INTERSECT_RANGE as "->*"
	SUBTRACT_RANGE as "->-"
}

interface CalculatorNode {
	op POLY_OBJECT_TYPE getType()
	op JNIObject getISLObject()
}

class PolyhedralObject extends AlphaNode, CalculatorNode, AlphaVisitable, AlphaSystemElement {
	String name
	contains CalculatorExpression expr
	
	op POLY_OBJECT_TYPE getType() { expr.^type }
	op JNIObject getISLObject() { 
		AlphaUtil.copy(expr.ISLObject)
	}
	
	op void accept(AlphaVisitor visitor) {
	 	visitor.visitPolyhedralObject(this)
	}
}

abstract class CalculatorExpression extends AlphaNode, CalculatorNode, CalculatorExpressionVisitable {
//	String errorMessage
	
	op void accept(CalculatorExpressionVisitor visitor) {
		visitor.visitCalculatorExpression(this);
	}
	
	/**
	 * toString without using ISL objects 
	 */
	op String plainToString() {
		throw new UnsupportedOperationException();
	}
}

class JNIDomain extends CalculatorExpression {
	String islString
	JNIISLSet z__internal_cache_islSet
	
	op JNIISLSet getISLSet() { if (z__internal_cache_islSet !== null) z__internal_cache_islSet.copy else null }
	op void setISLSet(JNIISLSet islset) { z__internal_cache_islSet = islset }
	
	op POLY_OBJECT_TYPE getType() { if (z__internal_cache_islSet !== null) POLY_OBJECT_TYPE::SET  else null }
	op JNIObject getISLObject() { getISLSet }
	
	op String toString() {
		if (z__internal_cache_islSet !== null) {
			return z__internal_cache_islSet.toString(ISL_FORMAT::ISL);
		} else {
			return "null ISL object"
		}
	}
	
	op String plainToString() {
		islString
	}
	
	op void accept(CalculatorExpressionVisitor visitor) {
		visitor.visitJNIDomain(this);
	}
}
class JNIDomainInArrayNotation extends JNIDomain {
	
}

class JNIRelation extends CalculatorExpression {
	String islString
	JNIISLMap z__internal_cache_islMap
	
	op JNIISLMap getISLMap() { if (z__internal_cache_islMap !== null) z__internal_cache_islMap.copy else null }
	op void setISLMap(JNIISLMap islMap) { z__internal_cache_islMap = islMap }
	
	op POLY_OBJECT_TYPE getType() { if (z__internal_cache_islMap !== null) POLY_OBJECT_TYPE::MAP else null }
	op JNIObject getISLObject() { ISLMap }
	
	op String toString() {
		if (z__internal_cache_islMap !== null) {
			return z__internal_cache_islMap.toString(ISL_FORMAT::ISL);
		} else {
			return "null ISL object"
		}
	}
	
	op String plainToString() {
		islString
	}
	
	op void accept(CalculatorExpressionVisitor visitor) {
		visitor.visitJNIRelation(this);
	}
}

class JNIFunction extends CalculatorExpression {
	contains AlphaFunction alphaFunction
	JNIISLMultiAff z__internal_cache_islMAff
	
	op JNIISLMultiAff getISLMultiAff() { if (z__internal_cache_islMAff !== null) z__internal_cache_islMAff.copy else null }
	op void setISLMultiAff(JNIISLMultiAff islMAff) { z__internal_cache_islMAff = islMAff }
	
	op POLY_OBJECT_TYPE getType() { if (z__internal_cache_islMAff !== null) POLY_OBJECT_TYPE::FUNCTION else null }
	op JNIObject getISLObject() { ISLMultiAff }
	
	op void accept(CalculatorExpressionVisitor visitor) {
		visitor.visitJNIFunction(this);
	}
	
	op String plainToString() {
		if (ISLMultiAff === null) return ""
		AlphaPrintingUtil.toShowString(ISLMultiAff)
	}
}

class JNIFunctionInArrayNotation extends JNIFunction {
	String[] arrayNotation
	
	op String plainToString() {
		'[' + arrayNotation.join(",") + ']'
	}
}

class FuzzyFunction extends AlphaNode {
	String alphaString
	contains FuzzyVariableUse[] indirections
	JNIISLMap z__internal_cache_fuzzyMap
	JNIISLMap z__internal_cache_depRelation
	
	op JNIISLMap getFuzzyMap() { if (z__internal_cache_fuzzyMap !== null) z__internal_cache_fuzzyMap.copy else null }
	op void setFuzzyMap(JNIISLMap fuzzyMap) { z__internal_cache_fuzzyMap = fuzzyMap }
	
	op JNIISLMap getDependenceRelation() { if (z__internal_cache_depRelation !== null) z__internal_cache_depRelation.copy else null }
	op void setDependenceRelation(JNIISLMap depRel) { z__internal_cache_depRelation = depRel }
	
	op FuzzyVariableUse getIndirectionByName(String name) {
		indirections.findFirst[i|i.fuzzyIndex.contentEquals(name)]	
	}
	
}

abstract class FuzzyVariableUse extends AlphaNode {
	String fuzzyIndex
	refers FuzzyVariable fuzzyVariable

	//This method is identical to that in FuzzyFunction
	// 	however, AffineFuzzyVariable use do not inherit from FuzzyFunction, so we need a separate declaration
	op JNIISLMap getDependenceRelation()
}

class NestedFuzzyFunction extends FuzzyFunction, FuzzyVariableUse {
}

class AffineFuzzyVariableUse extends FuzzyVariableUse {
	contains JNIFunctionInArrayNotation useFunction
	
	op JNIISLMap getDependenceRelation() { 
		if (useFunction !== null && fuzzyVariable !== null && fuzzyVariable.relation !== null) 
			useFunction.ISLMultiAff.toMap.applyRange(fuzzyVariable.relation)
		else null
	}
}

class FuzzyFunctionInArrayNotation extends FuzzyFunction {
	String[] arrayNotation
	
	op String plainToString() {
		'[' + arrayNotation.join(",") + ']'
	}
}

class UnaryCalculatorExpression extends CalculatorExpression {
	CALCULATOR_UNARY_OP operator
	contains CalculatorExpression expr
	
	JNIObject z__internal_cache_islObject
	
	op POLY_OBJECT_TYPE getType() { 
		if (z__internal_cache_islObject instanceof JNIISLSet)
			return POLY_OBJECT_TYPE::SET
		if (z__internal_cache_islObject instanceof JNIISLMap)
			return POLY_OBJECT_TYPE::MAP
		return null
	}
	op JNIObject getISLObject() { 
		AlphaUtil.copy(z__internal_cache_islObject)
	}
	
	op void accept(CalculatorExpressionVisitor visitor) {
		visitor.visitUnaryCalculatorExpression(this);
	}
	
	op String plainToString() {
		operator + ' ' + expr.plainToString
	}
}

class BinaryCalculatorExpression extends CalculatorExpression {
	CALCULATOR_BINARY_OP operator
	contains CalculatorExpression left
	contains CalculatorExpression right
	
	JNIObject z__internal_cache_islObject
	
	op POLY_OBJECT_TYPE getType() { 
		if (z__internal_cache_islObject instanceof JNIISLSet)
			return POLY_OBJECT_TYPE::SET
		if (z__internal_cache_islObject instanceof JNIISLMap)
			return POLY_OBJECT_TYPE::MAP
		return null
	}
	
	op JNIObject getISLObject() { 
		AlphaUtil.copy(z__internal_cache_islObject)
	}

	op void accept(CalculatorExpressionVisitor visitor) {
		visitor.visitBinaryCalculatorExpression(this);
	}
	
	op String plainToString() {
		left.plainToString + ' ' + operator + ' ' + right.plainToString
	}
}

/* VariableDomain refers to the domain of declared variables */
class VariableDomain extends CalculatorExpression {
	refers Variable variable
	
	op POLY_OBJECT_TYPE getType() { return POLY_OBJECT_TYPE::SET }
	op JNIObject getISLObject() { if (variable !== null) variable.domain else null }
	
	op void accept(CalculatorExpressionVisitor visitor) {
		visitor.visitVariableDomain(this);
	}
	
	op String plainToString() {
		'{' + variable.name + '}'
	}
}

/* RectangularDomain is a short-hand for rectilinear domains bounded by 0 from below, and by some parameter from above.
 * The dimensionality of the domain is the length of upperBounds that give the upper bound for each dimension.
 * The index names can be optionally specified for each dimension. (It is not possible to only name a subset of the dimensions.)
 * 
 * The bounds are of the form: 0<=i<N; each dimension will have N integer points starting from 0. 
 */
class RectangularDomain extends CalculatorExpression {
	String[] lowerBounds
	String[] upperBounds
	String[] indexNames
	
	JNIISLSet z__internal_cache_islSet
	
	op JNIISLSet getISLSet() { if (z__internal_cache_islSet !== null) z__internal_cache_islSet.copy else null}
	op void setISLSet(JNIISLSet islset) { z__internal_cache_islSet = islset }
	
	op POLY_OBJECT_TYPE getType() { return POLY_OBJECT_TYPE::SET }
	op JNIObject getISLObject() { ISLSet }
	
	op void accept(CalculatorExpressionVisitor visitor) {
		visitor.visitRectangularDomain(this);
	}
	
	op String plainToString() {
		if (lowerBounds.length == upperBounds.length) {
			'[' + (0..<lowerBounds.length).map[i|lowerBounds.get(i) + ':' + upperBounds.get(i)].join(", ") + ']'
		} else {
			'[' + upperBounds.join(", ") + ']'
		}
	}
}

/* Reference to an already defined object in the calculator section */
class DefinedObject extends CalculatorExpression {
	refers PolyhedralObject object
	boolean z__internalCycleDetector
	
	op POLY_OBJECT_TYPE getType() { return object.getType }
	op JNIObject getISLObject() {
		
		if (object !== null) {
			if (z__internalCycleDetector) {
				throw new CyclicDefinitionException("Cycle detected in the definition of: " + object.name);
			}
			z__internalCycleDetector = true;
			val res = object.ISLObject
			z__internalCycleDetector = false
			return res
		}
		return null
	}
	
	op void accept(CalculatorExpressionVisitor visitor) {
		visitor.visitDefinedObject(this);
	}
	
	op String plainToString() {
		object.name
	}
}


/*
 * AlphaFunction is supposed to be just text in the Xtext grammar.
 * However, the ambiguity involving parentheses cause issues.
 * This can be resolved by actually parsing it as expressions.
 * 
 * It could be avoided by using square braces instead: [i,j->i,j]
 *  but I prefer to use the classical Alpha syntax for functions.
 */ 
class AlphaFunction {
	String indexList 
	contains AlphaFunctionExpression[] exprs
}

abstract class AlphaFunctionExpression {
	op String getISLString()
}

class AlphaFunctionBinaryExpression extends AlphaFunctionExpression {
	contains AlphaFunctionExpression left
	contains AlphaFunctionExpression right
	String operator	
	
	op String getISLString() { String.format("(%s %s %s)", left.ISLString, operator, right.ISLString) }
}

class AlphaFunctionLiteral extends AlphaFunctionExpression {
	String value
	
	op String getISLString() { value }
}
