@GenModel(
	operationReflection="false",
	loadInitialization="false",
	literalsInterface="true")
package alpha.model

import alpha.model.exception.CyclicDefinitionException
import alpha.model.util.AlphaUtil
import alpha.model.util.Face
import alpha.model.util.FaceLattice
import alpha.model.util.Show
import fr.irisa.cairn.jnimap.isl.ISL_FORMAT
import fr.irisa.cairn.jnimap.isl.ISLMultiAff
import fr.irisa.cairn.jnimap.isl.ISLPWQPolynomial
import fr.irisa.cairn.jnimap.isl.ISLMap
import fr.irisa.cairn.jnimap.isl.ISLSet
import fr.irisa.cairn.jnimap.runtime.JNIObject
import java.util.LinkedList
import java.util.List
import java.util.Queue
import org.eclipse.emf.common.util.BasicEList
import org.eclipse.xtext.EcoreUtil2
import org.eclipse.xtext.naming.DefaultDeclarativeQualifiedNameProvider
import org.eclipse.xtext.naming.IQualifiedNameProvider

//type JNIDomain wraps JNIDomain
type JNIObject wraps JNIObject
type JNIISLSet wraps ISLSet
type JNIISLMap wraps ISLMap
type JNIISLMultiAff wraps ISLMultiAff
type JNIISLPWQPolynomial wraps ISLPWQPolynomial
type ISL_FORMAT wraps ISL_FORMAT
type ListVariableExpression wraps List<VariableExpression> 
type IntegerQueue wraps Queue<Integer>
type String wraps String
type Face wraps Face
type FaceLattice wraps FaceLattice
type int wraps Integer
type float wraps Float
type double wraps Double
type boolean wraps Boolean

/*
 * Some conventions:
 *  polyhedral objects are either domains or relations in Alpha terms
 * the above is distinguished from ISL objects that are named sets or maps
 * 
 * TODO make sure calculator expression does not have cycles in its evaluation chain
 *   VariableDomain and DefinedObject should only refer to textually preceding definitions
 */

class AlphaNode {
	derived int[] nodeID get {
		val parentID = if (eContainer instanceof AlphaNode) {
			new BasicEList<Integer>((eContainer as AlphaNode).nodeID);
		} else {
			new BasicEList<Integer>();
		}
		if (eContainer !== null)
			parentID.add(eContainer.eContents.indexOf(this))
		return parentID
	}
	
	/**
	 * Returns a node in the AST as a result of following the path specified by
	 * the given vector. Each element of the vector is the index of the list
	 * returned by eContents.
	 * 
	 * Note that the nodeID is computed has AlphaRoot as its root. Thus,
	 * getNode must be called at AlphaNode to retrieve the right node.
	 * (It is best if the visibility can be restricted, but this is not supported by current Xcore.)
	 */
	op AlphaNode getNode(IntegerQueue nodeID) {
		val next = nodeID.poll;
		
		if (next === null) this
		else (this.eContents.get(next) as AlphaNode).getNode(nodeID);
	}
}


/**
 * Interface for AlphaCompleteVisitor, which actually is not complete in the sense it does not visit CalculatorExpression.
 * This is because CalculatorExpressions are separate data structure to describe polyhedral objects, which is tightly
 * coupled with JNIISL.
 * 
 */
interface AlphaCompleteVisitable {}

interface AlphaVisitable extends AlphaCompleteVisitable {
	op void accept(AlphaVisitor visitor)
}
interface AlphaExpressionVisitable extends AlphaCompleteVisitable {
	op void accept(AlphaExpressionVisitor visitor)
}
interface CalculatorExpressionVisitable {
	op void accept(CalculatorExpressionVisitor visitor)
}
interface AlphaSystemElement {}

/**
 * ScheduleTarget is what can be referred to from TargetMapping:
 *   - StandardEquation
 *   - UseEquation
 * 
 */
interface AlphaScheduleTarget {
	op String getName()
}

/**
 * Notes on visitors.
 * 
 * - Whenever you add a new node, the corresponding methods must be added to the visitor interface.
 * - Each node should have visitXXX, inXXX, outXXX methods.
 * - The default visiting pattern (depth first) is implemented in the corresponding default visitors. They need to be updated when a node is added as well.
 * - In the default visitor, inXXX and outXXX is called from visitXXX, where visitXXX calls accept on all its children. 
 * - The abstract visitor does not need to be modified, except for the CompleteVisitor that require bridging between two visitors.
 * 
 * The default methods are used so that the visiting pattern can be implemented at the interface of each visitor. 
 * This allows the complete visitor, which is made up of two visitors, to reuse the visiting code.  
 * 
 */
interface AlphaVisitor {
	op void visitAlphaRoot(AlphaRoot root)
	
	op void visitAlphaPackage(AlphaPackage ap)
	op void visitAlphaSystem(AlphaSystem system)
	op void visitSystemBody(SystemBody sysBody)
	op void visitImports(Imports imports)
	op void visitAlphaConstant(AlphaConstant ac)
	op void visitExternalFunction(ExternalFunction ef)
	
	/* Use specialized methods for input/output/local specific operations.
	 * The abstract visitor calls the specialized methods, which then calls the generic visitor.
	 */
	op void visitVariable(Variable variable)
	
	op void visitPolyhedralObject(PolyhedralObject pobj)

	op void visitUseEquation(UseEquation ue)
	op void visitStandardEquation(StandardEquation se)
	
	
	op void inAlphaRoot(AlphaRoot root)
	
	op void inAlphaElement(AlphaElement ap)
	op void inAlphaPackage(AlphaPackage ap)
	op void inAlphaSystem(AlphaSystem system)
	op void inSystemBody(SystemBody sysBody)
	op void inImports(Imports imports)
	op void inAlphaConstant(AlphaConstant ac)
	op void inExternalFunction(ExternalFunction ef)
	
	op void inVariable(Variable variable)
	
	op void inFuzzyVariable(FuzzyVariable variable)
	
	op void inPolyhedralObject(PolyhedralObject pobj)


	op void inEquation(Equation eq)
	op void inUseEquation(UseEquation ue)
	op void inStandardEquation(StandardEquation se)
	
	
	op void outAlphaRoot(AlphaRoot root)
	
	op void outAlphaElement(AlphaElement ap)
	op void outAlphaPackage(AlphaPackage ap)
	op void outAlphaSystem(AlphaSystem system)
	op void outSystemBody(SystemBody sysBody)
	op void outImports(Imports imports)
	op void outAlphaConstant(AlphaConstant ac)
	op void outExternalFunction(ExternalFunction ef)
	
	op void outVariable(Variable variable)
	
	op void outFuzzyVariable(FuzzyVariable variable)
	
	op void outPolyhedralObject(PolyhedralObject pobj)

	op void outEquation(Equation eq)
	op void outUseEquation(UseEquation ue)
	op void outStandardEquation(StandardEquation se)
}

interface AlphaExpressionVisitor {
	op void visitAlphaExpression(AlphaExpression ae)
	
	op void visitRestrictExpression(RestrictExpression re)
	op void visitAutoRestrictExpression(AutoRestrictExpression are)
	op void visitCaseExpression(CaseExpression ce)
	op void visitIfExpression(IfExpression ie)
	op void visitDependenceExpression(DependenceExpression de)
	op void visitFuzzyDependenceExpression(FuzzyDependenceExpression fde)
	op void visitAbstractReduceExpression(AbstractReduceExpression are)
	op void visitAbstractFuzzyReduceExpression(AbstractFuzzyReduceExpression afre)
	op void visitConvolutionExpression(ConvolutionExpression ce)
	op void visitUnaryExpression(UnaryExpression ue)
	op void visitBinaryExpression(BinaryExpression be)
	op void visitMultiArgExpression(MultiArgExpression mae)
	op void visitSelectExpression(SelectExpression se)
	
	op void visitIndexExpression(IndexExpression ie)
	op void visitPolynomialIndexExpression(PolynomialIndexExpression pie)
	op void visitFuzzyIndexExpression(FuzzyIndexExpression fie)
	op void visitVariableExpression(VariableExpression ve)
	
	op void visitIntegerExpression(IntegerExpression ie)
	op void visitRealExpression(RealExpression re)
	op void visitBooleanExpression(BooleanExpression be)
	
	op void inAlphaExpression(AlphaExpression ae)
	
	op void inRestrictExpression(RestrictExpression re)
	op void inAutoRestrictExpression(AutoRestrictExpression are)
	op void inCaseExpression(CaseExpression ce)
	op void inIfExpression(IfExpression ie)
	op void inDependenceExpression(DependenceExpression de)
	op void inFuzzyDependenceExpression(FuzzyDependenceExpression fde)
	op void inAbstractReduceExpression(AbstractReduceExpression are)
	op void inReduceExpression(ReduceExpression re)
	op void inArgReduceExpression(ArgReduceExpression are)
	op void inAbstractFuzzyReduceExpression(AbstractFuzzyReduceExpression afre)
	op void inFuzzyReduceExpression(FuzzyReduceExpression fre)
	op void inFuzzyArgReduceExpression(FuzzyArgReduceExpression fare)
	op void inConvolutionExpression(ConvolutionExpression ce)
	op void inUnaryExpression(UnaryExpression ue)
	op void inBinaryExpression(BinaryExpression be)
	op void inMultiArgExpression(MultiArgExpression mae)
	op void inSelectExpression(SelectExpression se)
	
	op void inIndexExpression(IndexExpression ie)
	op void inPolynomialIndexExpression(PolynomialIndexExpression pie)
	op void inFuzzyIndexExpression(FuzzyIndexExpression fie)
	op void inVariableExpression(VariableExpression ve)
	
	op void inConstantExpression(ConstantExpression ce)
	op void inIntegerExpression(IntegerExpression ie)
	op void inRealExpression(RealExpression re)
	op void inBooleanExpression(BooleanExpression be)
	
	op void inExternalReduceExpression(ExternalReduceExpression ere)
	op void inExternalArgReduceExpression(ExternalArgReduceExpression eare)
	op void inExternalMultiArgExpression(ExternalMultiArgExpression emae)
	op void inExternalFuzzyReduceExpression(ExternalFuzzyReduceExpression efre)
	op void inExternalFuzzyArgReduceExpression(ExternalFuzzyArgReduceExpression efare)
	
	op void outAlphaExpression(AlphaExpression ae)
	
	op void outRestrictExpression(RestrictExpression re)
	op void outAutoRestrictExpression(AutoRestrictExpression are)
	op void outCaseExpression(CaseExpression ce)
	op void outIfExpression(IfExpression ie)
	op void outDependenceExpression(DependenceExpression de)
	op void outFuzzyDependenceExpression(FuzzyDependenceExpression fde)
	op void outAbstractReduceExpression(AbstractReduceExpression are)
	op void outReduceExpression(ReduceExpression re)
	op void outArgReduceExpression(ArgReduceExpression are)
	op void outAbstractFuzzyReduceExpression(AbstractFuzzyReduceExpression afre)
	op void outFuzzyReduceExpression(FuzzyReduceExpression fre)
	op void outFuzzyArgReduceExpression(FuzzyArgReduceExpression fare)
	op void outConvolutionExpression(ConvolutionExpression ce)
	op void outUnaryExpression(UnaryExpression ue)
	op void outBinaryExpression(BinaryExpression be)
	op void outMultiArgExpression(MultiArgExpression mae)
	op void outSelectExpression(SelectExpression se)
	
	op void outIndexExpression(IndexExpression ie)
	op void outPolynomialIndexExpression(PolynomialIndexExpression pie)
	op void outFuzzyIndexExpression(FuzzyIndexExpression fie)
	op void outVariableExpression(VariableExpression ve)
	
	op void outConstantExpression(ConstantExpression ce)
	op void outIntegerExpression(IntegerExpression ie)
	op void outRealExpression(RealExpression re)
	op void outBooleanExpression(BooleanExpression be)
	
	op void outExternalReduceExpression(ExternalReduceExpression ere)
	op void outExternalArgReduceExpression(ExternalArgReduceExpression eare)
	op void outExternalMultiArgExpression(ExternalMultiArgExpression emae)
	op void outExternalFuzzyReduceExpression(ExternalFuzzyReduceExpression efre)
	op void outExternalFuzzyArgReduceExpression(ExternalFuzzyArgReduceExpression efare)
}

interface CalculatorExpressionVisitor {
	op void visitCalculatorExpression(CalculatorExpression expr)
	
	op void visitUnaryCalculatorExpression(UnaryCalculatorExpression expr)
	op void visitBinaryCalculatorExpression(BinaryCalculatorExpression expr)
	
	op void visitJNIDomain(JNIDomain jniDomain)
	op void visitJNIRelation(JNIRelation jniRelation)
	op void visitJNIFunction(JNIFunction jniFunction)
	op void visitJNIPolynomial(JNIPolynomial jniPolynomial)
	
	op void visitVariableDomain(VariableDomain vdom)
	op void visitRectangularDomain(RectangularDomain rdom)
	op void visitDefinedObject(DefinedObject dobj)
}

class AlphaRoot extends AlphaNode, AlphaVisitable {
	contains Imports[] imports
	contains AlphaElement[] elements
	
	op AlphaConstant[] getConstants() { EcoreUtil2.getAllContentsOfType(this, AlphaConstant).asEList }
	op ExternalFunction[] getExternalFunctions() { EcoreUtil2.getAllContentsOfType(this, ExternalFunction).asEList }
	op AlphaPackage[] getPackages() { EcoreUtil2.getAllContentsOfType(this, AlphaPackage).asEList }
	op AlphaSystem[] getSystems() { EcoreUtil2.getAllContentsOfType(this, AlphaSystem).asEList }
	
	op AlphaSystem getSystem(String name) {
		//qualified name
		if (name.contains('.')) {
			val system =  EcoreUtil2.getAllContentsOfType(this, AlphaSystem).findFirst[s|s.getFullyQualifiedName.contentEquals(name)]
			if (system !== null) return system
		//just the system name
		} else {
			val system = EcoreUtil2.getAllContentsOfType(this, AlphaSystem).findFirst[s|s.name.contentEquals(name)]
			if (system !== null) return system
		}
		
		throw new RuntimeException("System " + name + " was not found.");
	}
	
	op void accept(AlphaVisitor visitor) {
		visitor.visitAlphaRoot(this)
	}
	
	op AlphaNode getNode(int[] nodeID) {
		getNode(new LinkedList(nodeID))
	}
	
	op AlphaNode getNode(String nodeID) {
		getNode(new LinkedList(AlphaUtil.parseIntArray(nodeID)))
	}
}

/**
 * AlphaElement is introduced to allow systems, packages, constants, and exFuns, to appear in any order.
 * The imports must be at the beginning of the file.
 * 
 */
interface AlphaElement extends AlphaNode, AlphaVisitable {
}

class Imports extends AlphaNode, AlphaVisitable {
	String importedNamespace
	
	op void accept(AlphaVisitor visitor) {
		visitor.visitImports(this)
	}
}

class AlphaPackage extends AlphaElement {
	 String name
	 contains AlphaElement[] elements
	 
	op AlphaConstant[] getConstants() { elements.filter(AlphaConstant).asEList }
	op ExternalFunction[] getExternalFunctions() { elements.filter(ExternalFunction).asEList }
	op AlphaPackage[] getPackages() { elements.filter(AlphaPackage).asEList }
	op AlphaSystem[] getSystems() { elements.filter(AlphaSystem).asEList }
	 
	 op void accept(AlphaVisitor visitor) {
		visitor.visitAlphaPackage(this)
	}
}

class AlphaConstant extends AlphaElement {
	String name
	int value 
	
	op void accept(AlphaVisitor visitor) {
		visitor.visitAlphaConstant(this)
	}
}

class ExternalFunction extends AlphaElement {
	String name
	int cardinality
	
	op String getFullyQualifiedName() {
		val IQualifiedNameProvider provider = new DefaultDeclarativeQualifiedNameProvider;
		provider.getFullyQualifiedName(this).toString
	}
	
	op void accept(AlphaVisitor visitor) {
		visitor.visitExternalFunction(this)
	}
}

class AlphaSystem extends AlphaElement {
	String name
	contains JNIDomain parameterDomainExpr
	contains PolyhedralObject[] definedObjects
	contains Variable[] inputs
	contains Variable[] outputs
	contains Variable[] locals
	contains CalculatorExpression whileDomainExpr
	contains AlphaExpression testExpression
	
	contains SystemBody[] systemBodies opposite system
	
	op Variable[] getVariables() {
		(inputs+outputs+locals).asEList.unmodifiableEList
	}
	
	op JNIISLSet getParameterDomain() {
		return parameterDomainExpr.ISLSet
	}
	
	op JNIISLSet getWhileDomain() {
		if (whileDomainExpr === null || whileDomainExpr.^type != POLY_OBJECT_TYPE::SET) null 
		else (whileDomainExpr.ISLObject as ISLSet).copy
	}
	
	op Variable getVariable(String varName) {
		return getVariables.findFirst[v|v.name.contentEquals(varName)]
	}
	
	op String getFullyQualifiedName() {
		val IQualifiedNameProvider provider = new DefaultDeclarativeQualifiedNameProvider;
		provider.getFullyQualifiedName(this).toString
	}
	
	op void accept(AlphaVisitor visitor) {
		visitor.visitAlphaSystem(this)
	}
}


class Variable extends AlphaNode, AlphaVisitable, AlphaSystemElement {
	String name
	contains CalculatorExpression domainExpr
	
	op JNIISLSet getDomain() {
		if (domainExpr === null || domainExpr.^type != POLY_OBJECT_TYPE::SET) {
			return null
		}
		
		try {
			return if (domainExpr.^type != POLY_OBJECT_TYPE::SET) null else domainExpr.ISLObject as ISLSet
		} catch (CyclicDefinitionException cde) {
			return null
		}
	}
	
	op boolean isInput() {
		eContainmentFeature !== null && eContainmentFeature === ModelPackage.Literals.ALPHA_SYSTEM__INPUTS
	}
	op boolean isOutput() {
		eContainmentFeature !== null && eContainmentFeature === ModelPackage.Literals.ALPHA_SYSTEM__OUTPUTS
	}
	op boolean isLocal() {
		eContainmentFeature !== null && eContainmentFeature === ModelPackage.Literals.ALPHA_SYSTEM__LOCALS
	}
	
	 op void accept(AlphaVisitor visitor) {
	 	visitor.visitVariable(this)
	}
}

class FuzzyVariable extends Variable {
	contains CalculatorExpression rangeExpr
	
	op JNIISLSet getRange() {
		return if (rangeExpr.^type != POLY_OBJECT_TYPE::SET) null else rangeExpr.ISLObject as ISLSet
	}
	
	op JNIISLMap getRelation() {
		val dom = domain
		val ran = range
		if (dom === null || ran === null) null else dom.product(ran).unwrap
	}
	
	op void accept(AlphaVisitor visitor) {
	 	visitor.visitVariable(this)
	}
}

class SystemBody extends AlphaNode, AlphaVisitable, AlphaSystemElement {
	container AlphaSystem system opposite systemBodies
	contains JNIDomain parameterDomainExpr
	contains Equation[] equations opposite systemBody
	
	op JNIISLSet getParameterDomain() {
		return parameterDomainExpr.ISLSet
	}
	
	op UseEquation[] getUseEquations() {
		equations.getObjectsByType(ModelPackage.Literals.USE_EQUATION).asEList
	}
	op StandardEquation[] getStandardEquations() {
		equations.getObjectsByType(ModelPackage.Literals.STANDARD_EQUATION).asEList
	}
	
//	op Variable getEquation(String eqName) {
//		val v = standard.findFirst[eq|e.name.contentEquals(varName)]
//		
//		if (v === null) {
//			throw new RuntimeException(String.format("Variable %s does not exist in system %s ", varName, this.name));
//		}
//		
//		return v
//	}

	op StandardEquation getStandardEquation(String eqName) {
		standardEquations.findFirst[eq|eq.variable.name.contentEquals(eqName)]
	}
	
	op StandardEquation getStandardEquation(Variable v) {
		standardEquations.findFirst[eq|eq.variable == v]
	}
//	
//	op UseEquation getUseEquation(String eqName) {
//		ue.
//		
////		val v = useEquations.filter[ue|EcoreUtil2.getAllContentsOfType(ue, VariableExpression).filter[ve|ve.variable.name]]
////		
////		if (v === null) {
////			throw new RuntimeException(String.format("StanardEquation for %s does not exist in system %s ", eqName, this.system.name));
////		}
////		
////		return v
//	}
	
	op void accept(AlphaVisitor visitor) {
		visitor.visitSystemBody(this)
	}
}

abstract class Equation extends AlphaNode, AlphaVisitable, AlphaSystemElement, AlphaScheduleTarget {
	container SystemBody systemBody opposite equations
	
	boolean z__explored
	
	op AlphaExpression getExpression(IntegerQueue exprID) {
		val next = exprID.poll;
		
		if (next === null) throw new RuntimeException("Invalid Expression ID")
		else (this.eContents.get(next) as AlphaExpression).getExpression(exprID);
	}
	
	op AlphaExpression getExpression(int[] exprID) {
		getExpression(new LinkedList(exprID))
	}
	
	op AlphaExpression getExpression(String exprIDstr) {
		getExpression(new LinkedList(AlphaUtil.parseIntArray(exprIDstr)))
	}
	
	op boolean getExplored() {
		if (z__explored === null)
			return false
		return z__explored
	}
	
	op void setExplored() {
		this.z__explored = true
	}
	
	op void setExplored(boolean explored) {
		this.z__explored = explored
	}
	
}

class StandardEquation extends Equation {
	refers Variable variable
	String[] indexNames
	contains AlphaExpression expr
	
	op String getName() {
		if (variable !== null) variable.name else null
	}
	
	op void accept(AlphaVisitor visitor) {
		visitor.visitStandardEquation(this)
	}
	
	op String toString() {
		val hasBeenExplored = if (explored) '*' else ' '
		return variable.name + ' ('+hasBeenExplored+'): ' + Show.print(expr)
	}
}
class UseEquation extends Equation {
	String identifier
	contains CalculatorExpression instantiationDomainExpr
	String[] subsystemDims
	refers AlphaSystem system
	contains JNIFunctionInArrayNotation callParamsExpr
	contains AlphaExpression[] inputExprs
	contains AlphaExpression[] outputExprs
	
	op String getName() {
		if (identifier !== null) 
			identifier
		else
			if (system !== null) system.name else null 
	}
	
	op JNIISLMultiAff getCallParams() {
		if (callParamsExpr.^type != POLY_OBJECT_TYPE.FUNCTION) null
		else callParamsExpr.ISLObject as ISLMultiAff
	}
	
	op JNIISLSet getInstantiationDomain() {
		if (instantiationDomainExpr.^type != POLY_OBJECT_TYPE.SET) null
		else instantiationDomainExpr.ISLObject as ISLSet
	}
	
	op ListVariableExpression getAllVariableExpressionsInOutputExpressions() {
		var List<VariableExpression> list = new LinkedList<VariableExpression>();
		for(expr : outputExprs) {
			list.addAll(EcoreUtil2.getAllContentsOfType(expr, VariableExpression))
			
			if (expr instanceof VariableExpression) {
				list.add(expr);
			}
		}
		return list
	}
	
	op void accept(AlphaVisitor visitor) {
		visitor.visitUseEquation(this)
	}
}

/** Alpha Expressions 
 *
 * XCore does not provide a way to make private variables in the classes. The current work around 
 * is to use long and obvious names for internal variables that are not meant to be accessed. In
 * the AlphaExpression classes, these variables are prefixed by z__internal, where the leading
 * 'z' makes the corresponding methods to show up at the bottom of the content assist.
 * 
 * For JNIISL objects, any getter should return a copy of the object to ensure that the object
 * will not be taken by ISL.
 * 
 */
abstract class AlphaExpression extends AlphaNode, AlphaExpressionVisitable {
	/*Internal object for always copying expression domain at getter */
	JNIISLSet z__internal_cache_exprDom
	/*Internal object for always copying context domain at getter */
	JNIISLSet z__internal_cache_contextDom
	
	derived int[] expressionID get {
		val parentID = if (eContainer instanceof AlphaExpression) {
			new BasicEList<Integer>((eContainer as AlphaExpression).expressionID);
		} else {
			new BasicEList<Integer>();
		}
		parentID.add(eContainer.eContents.indexOf(this))
		return parentID
	}
	
	op void setExpressionDomain(JNIISLSet dom) { this.setZ__internal_cache_exprDom(dom.coalesce.ensureDomainIsNamed) }
	op JNIISLSet getExpressionDomain() { if (z__internal_cache_exprDom !== null) z__internal_cache_exprDom.copy else null }
	
	op void setContextDomain(JNIISLSet dom) { this.setZ__internal_cache_contextDom(dom.coalesce.ensureDomainIsNamed) }
	op JNIISLSet getContextDomain() { if (z__internal_cache_contextDom !== null)  z__internal_cache_contextDom.copy else null }
	
	op AlphaExpression getExpression(IntegerQueue exprID) {
		val next = exprID.poll;
		
		if (next === null) this
		else (this.eContents.get(next) as AlphaExpression).getExpression(exprID);
	}
	
	/**
	 * Depending on how the ISLSet was calculated (for either the expression domain or the context domain),
	 * the indices of the set might not be named (or a subset of them might not be named).
	 * In this case, issues may arise when trying to use the domain.
	 * To counteract this, if there is not a name for every index,
	 * then replace all the names with the default index names.
	 */
	op JNIISLSet ensureDomainIsNamed(JNIISLSet dom) {
		val indexNames = dom.indexNames
		val indexCount = dom.nbIndices
		
		if ((indexNames !== null) && (indexNames.size == indexCount)) {
			return dom
		}
		
		return AlphaUtil.renameIndices(dom)
	}
	
	op String toString() {
		return Show.print(this)
	}
}

class RestrictExpression extends AlphaExpression {
	contains CalculatorExpression domainExpr
	contains AlphaExpression expr
	
	op JNIISLSet getRestrictDomain() {
		if (domainExpr.^type != POLY_OBJECT_TYPE.SET ) null
		else domainExpr.ISLObject as ISLSet
	}
	
	op void accept(AlphaExpressionVisitor visitor) {
		visitor.visitRestrictExpression(this)
	}
}
class AutoRestrictExpression extends AlphaExpression {
	contains AlphaExpression expr
	JNIISLSet z__internal_cache_inferredDomain
	
	op JNIISLSet getInferredDomain() { if (z__internal_cache_inferredDomain !== null) z__internal_cache_inferredDomain.copy else null }
	op void setInferredDomain(JNIISLSet islset) { z__internal_cache_inferredDomain = islset }
		
	op void accept(AlphaExpressionVisitor visitor) {
		visitor.visitAutoRestrictExpression(this)
	}
}

class CaseExpression extends AlphaExpression {
	String name
	contains AlphaExpression[] exprs
	
	op boolean isNamed() {
		name !== null && name.length > 0
	}
	
	op void accept(AlphaExpressionVisitor visitor) {
		visitor.visitCaseExpression(this)
	}
}
class DependenceExpression extends AlphaExpression {
	contains JNIFunction functionExpr
	contains AlphaExpression expr
	
	op JNIISLMultiAff getFunction() {
		if (functionExpr.^type != POLY_OBJECT_TYPE.FUNCTION ) null
		else functionExpr.ISLObject as ISLMultiAff
	}
	
	op void accept(AlphaExpressionVisitor visitor) {
		visitor.visitDependenceExpression(this)
	}
}
class FuzzyDependenceExpression extends AlphaExpression {
	contains FuzzyFunction fuzzyFunction
	contains AlphaExpression expr
	
	op JNIISLMap getDependenceRelation() {
		if (fuzzyFunction !== null) fuzzyFunction.dependenceRelation else null
	}
	
	op void accept(AlphaExpressionVisitor visitor) {
		visitor.visitFuzzyDependenceExpression(this)
	}
}
class IfExpression extends AlphaExpression {
	contains AlphaExpression condExpr
	contains AlphaExpression thenExpr
	contains AlphaExpression elseExpr
	
	op void accept(AlphaExpressionVisitor visitor) {
		visitor.visitIfExpression(this)
	}
}
class IndexExpression extends AlphaExpression {
	contains JNIFunction functionExpr
	
	op JNIISLMultiAff getFunction() {
		if (functionExpr.^type != POLY_OBJECT_TYPE.FUNCTION ) null
		else functionExpr.ISLObject as ISLMultiAff
	}
	
	op void accept(AlphaExpressionVisitor visitor) {
		visitor.visitIndexExpression(this)
	}
}
class PolynomialIndexExpression extends AlphaExpression {
	contains JNIPolynomial polynomialExpr
	
	op JNIISLPWQPolynomial getPolynomial() {
		if (polynomialExpr.^type != POLY_OBJECT_TYPE.POLYNOMIAL ) null
		else polynomialExpr.ISLObject as ISLPWQPolynomial
	}
	
	op void accept(AlphaExpressionVisitor visitor) {
		visitor.visitPolynomialIndexExpression(this)
	}
}
class FuzzyIndexExpression extends AlphaExpression {	
	contains FuzzyFunction fuzzyFunction
	
	op JNIISLMap getDependenceRelation() {
		if (fuzzyFunction !== null) fuzzyFunction.dependenceRelation else null
	}
	
	op void accept(AlphaExpressionVisitor visitor) {
		visitor.visitFuzzyIndexExpression(this)
	}
}


abstract class AbstractReduceExpression extends AlphaExpression {
	REDUCTION_OP operator
	contains JNIFunction projectionExpr
	contains AlphaExpression body
	Face z__internal_facet
	int nbFreeDimensionsInBody
	
	op JNIISLMultiAff getProjection() {
		if (projectionExpr.^type != POLY_OBJECT_TYPE.FUNCTION ) null
		else projectionExpr.ISLObject as ISLMultiAff
	}
	
	op void accept(AlphaExpressionVisitor visitor) {
		visitor.visitAbstractReduceExpression(this)
	}
	
	op Face getFacet() { if (z__internal_facet === null) FaceLattice.create(body.contextDomain).root else z__internal_facet }
	op void setFacet(Face face) { z__internal_facet = facet }
}
class ReduceExpression extends AbstractReduceExpression {
	
	op void accept(AlphaExpressionVisitor visitor) {
		visitor.visitAbstractReduceExpression(this)
	}
}
class ExternalReduceExpression extends ReduceExpression {
	refers ExternalFunction externalFunction
	
	op void accept(AlphaExpressionVisitor visitor) {
		visitor.visitAbstractReduceExpression(this)
	}
}
class ArgReduceExpression extends AbstractReduceExpression {
	
	op void accept(AlphaExpressionVisitor visitor) {
		visitor.visitAbstractReduceExpression(this)
	}
}
class ExternalArgReduceExpression extends ArgReduceExpression {
	refers ExternalFunction externalFunction
	
	op void accept(AlphaExpressionVisitor visitor) {
		visitor.visitAbstractReduceExpression(this)
	}
}
class ConvolutionExpression extends AlphaExpression {
	contains CalculatorExpression kernelDomainExpr
	contains AlphaExpression kernelExpression
	contains AlphaExpression dataExpression
	
	op JNIISLSet getKernelDomain() {
		if (kernelDomainExpr.^type != POLY_OBJECT_TYPE.SET ) null
		else kernelDomainExpr.ISLObject as ISLSet
	}

	op void accept(AlphaExpressionVisitor visitor) {
		visitor.visitConvolutionExpression(this)
	}
}
class SelectExpression extends AlphaExpression {
	contains CalculatorExpression relationExpr
	contains AlphaExpression expr
	
	op JNIISLMap getSelectRelation() {
		if (relationExpr.^type != POLY_OBJECT_TYPE.MAP) null
		else relationExpr.ISLObject as ISLMap
	}

	op void accept(AlphaExpressionVisitor visitor) {
		visitor.visitSelectExpression(this)
	}
}
class VariableExpression extends AlphaExpression {
	refers Variable variable
	
	op void accept(AlphaExpressionVisitor visitor) {
		visitor.visitVariableExpression(this)
	}
}
interface ConstantExpression extends AlphaExpression {
	
	op String valueString()
}
class IntegerExpression extends ConstantExpression {
	int value
	
	op String valueString() { value+"" }
	
	op void accept(AlphaExpressionVisitor visitor) {
		visitor.visitIntegerExpression(this)
	}
}
class RealExpression extends ConstantExpression {
	float value
	
	op String valueString() { value+"" }
	
	op void accept(AlphaExpressionVisitor visitor) {
		visitor.visitRealExpression(this)
	}
}
class BooleanExpression extends ConstantExpression {
	boolean value
	
	op String valueString() { value+"" }
	
	op void accept(AlphaExpressionVisitor visitor) {
		visitor.visitBooleanExpression(this)
	}
}
class UnaryExpression extends AlphaExpression {
	UNARY_OP operator
	contains AlphaExpression expr
	
	op void accept(AlphaExpressionVisitor visitor) {
		visitor.visitUnaryExpression(this)
	}
}
class BinaryExpression extends AlphaExpression {
	BINARY_OP operator
	contains AlphaExpression left
	contains AlphaExpression right
	
	op void accept(AlphaExpressionVisitor visitor) {
		visitor.visitBinaryExpression(this)
	}
}
class MultiArgExpression extends AlphaExpression {
	REDUCTION_OP operator
	contains AlphaExpression[] exprs
	
	op void accept(AlphaExpressionVisitor visitor) {
		visitor.visitMultiArgExpression(this)
	}
}
class ExternalMultiArgExpression extends MultiArgExpression {
	refers ExternalFunction externalFunction 
	
	op void accept(AlphaExpressionVisitor visitor) {
		visitor.visitMultiArgExpression(this)
	}
}

abstract class AbstractFuzzyReduceExpression extends AlphaExpression {
	REDUCTION_OP operator
	contains FuzzyFunction projectionFunction
	contains AlphaExpression body
	
	op JNIISLMap getProjection() {
		if (projectionFunction !== null) projectionFunction.dependenceRelation else null
	}
	
	op void accept(AlphaExpressionVisitor visitor) {
		visitor.visitAbstractFuzzyReduceExpression(this)
	}
}
class FuzzyReduceExpression extends AbstractFuzzyReduceExpression {
	
	op void accept(AlphaExpressionVisitor visitor) {
		visitor.visitAbstractFuzzyReduceExpression(this)
	}
}
class ExternalFuzzyReduceExpression extends FuzzyReduceExpression {
	refers ExternalFunction externalFunction
	
	op void accept(AlphaExpressionVisitor visitor) {
		visitor.visitAbstractFuzzyReduceExpression(this)
	}
}
class FuzzyArgReduceExpression extends AbstractFuzzyReduceExpression {
	
	op void accept(AlphaExpressionVisitor visitor) {
		visitor.visitAbstractFuzzyReduceExpression(this)
	}
}
class ExternalFuzzyArgReduceExpression extends FuzzyArgReduceExpression {
	refers ExternalFunction externalFunction
	
	op void accept(AlphaExpressionVisitor visitor) {
		visitor.visitAbstractFuzzyReduceExpression(this)
	}
}

enum UNARY_OP {
	NOT as "not"
	NEGATE as "-"
}

enum BINARY_OP {
	MIN as "min"
	MAX as "max"
	
	MUL as "*"
	DIV as "/"
	MOD as "%"
	
	ADD as "+"
	SUB as "-"
	
	AND as "and"
	OR  as "or"
	XOR as "xor"
	
	EQ as "="
	NE as "!="
	GE as ">="
	GT as ">"
	LE as "<="
	LT as "<"
}

enum REDUCTION_OP {
	MIN as "min"
	MAX as "max"
	PROD as "prod"
	SUM as "sum"
	AND as "and"
	OR as "or"
	XOR as "xor"
	
	EX as "external"
}


/** Calculator Expressions **/
enum POLY_OBJECT_TYPE {
	SET
	MAP
	FUNCTION
	POLYNOMIAL
}

enum CALCULATOR_UNARY_OP {
	GET_DOMAIN as "domain"
	GET_RANGE as "range"
	COMPLEMENT as "complement"
	POLYHEDRAL_HULL as "poly-hull"
	AFFINE_HULL as "affine-hull"
	REVERSE as "reverse"
}

enum CALCULATOR_BINARY_OP {
	INTERSECT as "*"
	UNION as "+"
	CROSS_PRODUCT as "cross"
	SET_DIFFERENCE as "-"
	JOIN as "@"
	INTERSECT_RANGE as "intersectRange"
	SUBTRACT_RANGE as "subtractRange"
}

interface CalculatorNode {
	op POLY_OBJECT_TYPE getType()
	op JNIObject getISLObject()
}

class PolyhedralObject extends AlphaNode, CalculatorNode, AlphaVisitable, AlphaSystemElement {
	String name
	contains CalculatorExpression expr
	
	op POLY_OBJECT_TYPE getType() { expr.^type }
	op JNIObject getISLObject() { 
		AlphaUtil.copy(expr.ISLObject)
	}
	
	op void accept(AlphaVisitor visitor) {
	 	visitor.visitPolyhedralObject(this)
	}
}

abstract class CalculatorExpression extends AlphaNode, CalculatorNode, CalculatorExpressionVisitable {
//	String errorMessage
	
	op void accept(CalculatorExpressionVisitor visitor) {
		visitor.visitCalculatorExpression(this);
	}
	
	/**
	 * toString without using ISL objects 
	 */
	op String plainToString() {
		throw new UnsupportedOperationException();
	}
}

class JNIDomain extends CalculatorExpression {
	String islString
	JNIISLSet z__internal_cache_islSet
	
	op JNIISLSet getISLSet() { if (z__internal_cache_islSet !== null) z__internal_cache_islSet.copy else null }
	op void setISLSet(JNIISLSet islset) { z__internal_cache_islSet = islset }
	
	op POLY_OBJECT_TYPE getType() { if (z__internal_cache_islSet !== null) POLY_OBJECT_TYPE::SET  else null }
	op JNIObject getISLObject() { getISLSet }
	
	op String toString() {
		if (z__internal_cache_islSet !== null) {
			return z__internal_cache_islSet.toString(ISL_FORMAT::ISL);
		} else {
			return "null ISL object"
		}
	}
	
	op String plainToString() {
		islString
	}
	
	op void accept(CalculatorExpressionVisitor visitor) {
		visitor.visitJNIDomain(this);
	}
}
class JNIDomainInArrayNotation extends JNIDomain {
	
}

class JNIRelation extends CalculatorExpression {
	String islString
	JNIISLMap z__internal_cache_islMap
	
	op JNIISLMap getISLMap() { if (z__internal_cache_islMap !== null) z__internal_cache_islMap.copy else null }
	op void setISLMap(JNIISLMap islMap) { z__internal_cache_islMap = islMap }
	
	op POLY_OBJECT_TYPE getType() { if (z__internal_cache_islMap !== null) POLY_OBJECT_TYPE::MAP else null }
	op JNIObject getISLObject() { ISLMap }
	
	op String toString() {
		if (z__internal_cache_islMap !== null) {
			return z__internal_cache_islMap.toString(ISL_FORMAT::ISL);
		} else {
			return "null ISL object"
		}
	}
	
	op String plainToString() {
		islString
	}
	
	op void accept(CalculatorExpressionVisitor visitor) {
		visitor.visitJNIRelation(this);
	}
}

class JNIFunction extends CalculatorExpression {
	contains AlphaFunction alphaFunction
	JNIISLMultiAff z__internal_cache_islMAff
	
	op JNIISLMultiAff getISLMultiAff() { if (z__internal_cache_islMAff !== null) z__internal_cache_islMAff.copy else null }
	op void setISLMultiAff(JNIISLMultiAff islMAff) { z__internal_cache_islMAff = islMAff.ensureDomainAndRangeAreNamed }
	
	op POLY_OBJECT_TYPE getType() { if (z__internal_cache_islMAff !== null) POLY_OBJECT_TYPE::FUNCTION else null }
	op JNIObject getISLObject() { ISLMultiAff }
	
	op void accept(CalculatorExpressionVisitor visitor) {
		visitor.visitJNIFunction(this);
	}
	
	op String plainToString() {
		alphaFunction.plainToString()
	}
	
	/**
	 * Sometimes the ISLMutliAff does not have any input or output 
	 * names (i.e., is null). In this case, issues may arise when 
	 * trying to use the domain and range. To counteract this, if 
	 * there is not a name for every index, then replace all the 
	 * names with the default index names.
	 */
	op JNIISLMultiAff ensureDomainAndRangeAreNamed(JNIISLMultiAff maff) {
		val inputNames = maff.space.inputNames
		val inputCount = maff.space.nbInputs
		val outputNames = maff.space.outputNames
		val outputCount = maff.space.nbOutputs
		var retMaff = maff
		
		if ((inputNames === null) || (inputNames.size != inputCount)) {
			retMaff = AlphaUtil.renameInputs(maff)
		}
		if ((outputNames === null) || (outputNames.size != outputCount)) {
			retMaff = AlphaUtil.renameOutputs(maff)
		}	
		
		return retMaff
	}
}

class JNIFunctionInArrayNotation extends JNIFunction {
	String[] arrayNotation
	
	op String plainToString() {
		'[' + arrayNotation.join(",") + ']'
	}
}

class JNIPolynomial extends CalculatorExpression {
	String islString
	JNIISLPWQPolynomial z__internal_cache_islPWQP
	
	op JNIISLPWQPolynomial getISLPWQPolynomial() { if (z__internal_cache_islPWQP !== null) z__internal_cache_islPWQP.copy else null }
	op void setISLPWQPolynomial(JNIISLPWQPolynomial islQP) { z__internal_cache_islPWQP = islQP }
	
	op POLY_OBJECT_TYPE getType() { if (z__internal_cache_islPWQP !== null) POLY_OBJECT_TYPE::POLYNOMIAL else null }
	op JNIObject getISLObject() { ISLPWQPolynomial }
	
	op void accept(CalculatorExpressionVisitor visitor) {
		visitor.visitJNIPolynomial(this);
	}
	
	op String plainToString() {
		islString
	}
}

class JNIPolynomialInArrayNotation extends JNIPolynomial {
	String[] arrayNotation
	
	op String plainToString() {
		'[' + arrayNotation.join(",") + ']'
	}
}

class FuzzyFunction extends AlphaNode {
	String alphaString
	contains FuzzyVariableUse[] indirections
	JNIISLMap z__internal_cache_fuzzyMap
	JNIISLMap z__internal_cache_depRelation
	
	op JNIISLMap getFuzzyMap() { if (z__internal_cache_fuzzyMap !== null) z__internal_cache_fuzzyMap.copy else null }
	op void setFuzzyMap(JNIISLMap fuzzyMap) { z__internal_cache_fuzzyMap = fuzzyMap }
	
	op JNIISLMap getDependenceRelation() { if (z__internal_cache_depRelation !== null) z__internal_cache_depRelation.copy else null }
	op void setDependenceRelation(JNIISLMap depRel) { z__internal_cache_depRelation = depRel }
	
	op FuzzyVariableUse getIndirectionByName(String name) {
		indirections.findFirst[i|i.fuzzyIndex.contentEquals(name)]	
	}
}

abstract class FuzzyVariableUse extends AlphaNode {
	String fuzzyIndex
	refers FuzzyVariable fuzzyVariable

	//This method is identical to that in FuzzyFunction
	// 	however, AffineFuzzyVariable use do not inherit from FuzzyFunction, so we need a separate declaration
	op JNIISLMap getDependenceRelation()
}

class NestedFuzzyFunction extends FuzzyFunction, FuzzyVariableUse {
}

class AffineFuzzyVariableUse extends FuzzyVariableUse {
	contains JNIFunctionInArrayNotation useFunction
	
	op JNIISLMap getDependenceRelation() { 
		if (useFunction !== null && fuzzyVariable !== null && fuzzyVariable.relation !== null) 
			useFunction.ISLMultiAff.toMap.applyRange(fuzzyVariable.relation)
		else null
	}
}

class FuzzyFunctionInArrayNotation extends FuzzyFunction {
	String[] arrayNotation
	
	op String plainToString() {
		'[' + arrayNotation.join(",") + ']'
	}
}

class UnaryCalculatorExpression extends CalculatorExpression {
	CALCULATOR_UNARY_OP operator
	contains CalculatorExpression expr
	
	JNIObject z__internal_cache_islObject
	
	op POLY_OBJECT_TYPE getType() { 
		if (z__internal_cache_islObject instanceof ISLSet)
			return POLY_OBJECT_TYPE::SET
		if (z__internal_cache_islObject instanceof ISLMap)
			return POLY_OBJECT_TYPE::MAP
		return null
	}
	op JNIObject getISLObject() { 
		AlphaUtil.copy(z__internal_cache_islObject)
	}
	
	op void accept(CalculatorExpressionVisitor visitor) {
		visitor.visitUnaryCalculatorExpression(this);
	}
	
	op String plainToString() {
		operator + ' ' + expr.plainToString
	}
}

class BinaryCalculatorExpression extends CalculatorExpression {
	CALCULATOR_BINARY_OP operator
	contains CalculatorExpression left
	contains CalculatorExpression right
	
	JNIObject z__internal_cache_islObject
	
	op POLY_OBJECT_TYPE getType() { 
		if (z__internal_cache_islObject instanceof ISLSet)
			return POLY_OBJECT_TYPE::SET
		if (z__internal_cache_islObject instanceof ISLMap)
			return POLY_OBJECT_TYPE::MAP
		return null
	}
	
	op JNIObject getISLObject() { 
		AlphaUtil.copy(z__internal_cache_islObject)
	}

	op void accept(CalculatorExpressionVisitor visitor) {
		visitor.visitBinaryCalculatorExpression(this);
	}
	
	op String plainToString() {
		left.plainToString + ' ' + operator + ' ' + right.plainToString
	}
}

/* VariableDomain refers to the domain of declared variables */
class VariableDomain extends CalculatorExpression {
	refers Variable variable
	
	op POLY_OBJECT_TYPE getType() { return POLY_OBJECT_TYPE::SET }
	op JNIObject getISLObject() { if (variable !== null) variable.domain else null }
	
	op void accept(CalculatorExpressionVisitor visitor) {
		visitor.visitVariableDomain(this);
	}
	
	op String plainToString() {
		'{' + variable.name + '}'
	}
}

/* RectangularDomain is a short-hand for rectilinear domains bounded by 0 from below, and by some parameter from above.
 * The dimensionality of the domain is the length of upperBounds that give the upper bound for each dimension.
 * The index names can be optionally specified for each dimension. (It is not possible to only name a subset of the dimensions.)
 * 
 * The bounds are of the form: 0<=i<N; each dimension will have N integer points starting from 0. 
 */
class RectangularDomain extends CalculatorExpression {
	String[] lowerBounds
	String[] upperBounds
	String[] indexNames
	
	JNIISLSet z__internal_cache_islSet
	
	op JNIISLSet getISLSet() { if (z__internal_cache_islSet !== null) z__internal_cache_islSet.copy else null}
	op void setISLSet(JNIISLSet islset) { z__internal_cache_islSet = islset }
	
	op POLY_OBJECT_TYPE getType() { return POLY_OBJECT_TYPE::SET }
	op JNIObject getISLObject() { ISLSet }
	
	op void accept(CalculatorExpressionVisitor visitor) {
		visitor.visitRectangularDomain(this);
	}
	
	op String plainToString() {
		if (lowerBounds.length == upperBounds.length) {
			'[' + (0..<lowerBounds.length).map[i|lowerBounds.get(i) + ':' + upperBounds.get(i)].join(", ") + ']'
		} else {
			'[' + upperBounds.join(", ") + ']'
		}
	}
}

/* Reference to an already defined object in the calculator section */
class DefinedObject extends CalculatorExpression {
	refers PolyhedralObject object
	boolean z__internalCycleDetector = "false"
	
	op POLY_OBJECT_TYPE getType() { return object.getType }
	op JNIObject getISLObject() {
		
		if (object !== null) {
			if (z__internalCycleDetector) {
				throw new CyclicDefinitionException("Cycle detected in the definition of: " + object.name);
			}
			z__internalCycleDetector = true;
			val res = object.ISLObject
			z__internalCycleDetector = false
			return res
		}
		return null
	}
	
	op void accept(CalculatorExpressionVisitor visitor) {
		visitor.visitDefinedObject(this);
	}
	
	op String plainToString() {
		object.name
	}
}


/*
 * AlphaFunction is supposed to be just text in the Xtext grammar.
 * However, the ambiguity involving parentheses cause issues.
 * This can be resolved by actually parsing it as expressions.
 * 
 * It could be avoided by using square braces instead: [i,j->i,j]
 *  but I prefer to use the classical Alpha syntax for functions.
 */ 
class AlphaFunction {
	String indexList 
	contains AlphaFunctionExpression[] exprs
	
	op String plainToString() {
		String.format("[%s]->[%s]", indexList, exprs.join(",", [e|e.getISLString]))
	}
}

abstract class AlphaFunctionExpression {
	op String getISLString()
}

class AlphaFunctionBinaryExpression extends AlphaFunctionExpression {
	contains AlphaFunctionExpression left
	contains AlphaFunctionExpression right
	String operator	
	
	op String getISLString() { String.format("(%s %s %s)", left.ISLString, operator, right.ISLString) }
}

class AlphaFunctionLiteral extends AlphaFunctionExpression {
	String value
	
	op String getISLString() { value }
}

class AlphaFunctionFloor extends AlphaFunctionExpression {
	contains AlphaFunctionExpression expr
	
	op String getISLString() { String.format("floor(%s)", expr.ISLString) }
}